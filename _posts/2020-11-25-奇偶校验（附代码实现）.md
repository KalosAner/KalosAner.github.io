---
layout:       post
title:        "奇偶校验（附代码实现）"
author:       "Kalos Aner"
header-style: text
catalog:      true
tags:
    - 后端

---

### 定义

**奇偶校验**(Parity Check)是一种校验代码传输正确性的方法。根据被传输的一组二进制代码的数位中“1”的个数是奇数或偶数来进行校验。采用奇数的称为奇校验，反之，称为偶校验。采用何种校验是事先规定好的。通常专门设置一个奇偶校验位，用它使这组代码中“1”的个数为奇数或偶数。若用奇校验，则当接收端收到这组代码时，校验“1”的个数是否为奇数，从而确定传输代码的正确性。

**简单来说就是：**

奇校验：使完整编码（有效位和校验位）中的"1"的个数为奇数个；
偶校验：使完整编码（有效位和校验位）中的"1"的个数为偶数个

### 示例

进入的数必须是7位以内的，然后二进制向左移一位，根据二进制中1的个数在后面加上1或者0（加0和没加一样），把二进制中1的个数凑成奇数个或者偶数个。

| 数据     | （1的个数） | 奇校验     | 偶校验     |
| -------- | ----------- | ---------- | ---------- |
| 000 0011 | （2）       | 000 0011 1 | 000 0011 0 |
| 000 0100 | （1）       | 000 0100 0 | 000 0100 1 |
| 111 1111 | （7）       | 111 1111 0 | 111 1111 1 |

### 代码

C语言实现：

```c
#include<stdio.h>
#include<string.h>

unsigned char add(char data)//奇校验 
{
    int i, cnt = 0;

    for (i = 0; i < 7; i++)//一个char型有7位
    {
        int temp = ((data >> i) & 1);//data >> i是向右移i个位置得到的值，((data >> i) & 1)是与1不同的个数
        cnt += temp;//cnt记录二进制下data中1的个数
    }

    unsigned char ans = data << 1;//左移1位 
    
    if (cnt % 2 == 0)//当cnt能够被2整除，即cnt是偶数，即1的个数是偶数
    {
        ans += 1;//在最右边加1
    }
    else//当cnt不能够被2整除，即cnt是奇数，即1的个数是奇数
    {
        ans += 0;//在最右边加0
    }
    return ans;
}

unsigned char add_2(char data)//偶校验 
{
    int i, cnt = 0;

    for (i = 0; i < 7; i++)//一个char型有7位
    {
        int temp = ((data >> i) & 1);//data >> i是向右移i个位置得到的值，((data >> i) & 1)是与1不同的个数
        cnt += temp;//cnt记录二进制下data中1的个数
    }

    unsigned char ans = data << 1;//左移1位 
    
    if (cnt % 2 == 0)//当cnt能够被2整除，即cnt是偶数，即1的个数是偶数
    {
        ans += 0;//在最右边加0
    }
    else//当cnt不能够被2整除，即cnt是奇数，即1的个数是奇数
    {
        ans += 1;//在最右边加1
    }
    return ans;
}

int main()
{
    char a;
    unsigned char b;
    scanf("%c", &a);
    b = add(a);
    printf("2进制结果表示为：");//输出b的2进制表示
    for (int i = 7; i >= 0; i--) {
        if (((b>>i) & 1) == 1)
            printf("1");
        else
            printf("0");
    } putchar(10);

    printf("8进制结果表示为：%o\n",b);//输出b的8进制表示

    printf("10进制结果表示为：%d\n",b);//输出b的10进制表示

    printf("16进制结果表示为：%x\n", b);//输出b的16进制表示
    
    return 0;
}
```

### 扩展

**奇偶校验的优缺点：**

1、奇偶校验有两种类型：奇校验和偶校验。奇偶校验位是一个表示给定位数的二进制数中1的个数是奇数或者偶数的二进制数，奇偶校验位是最简单的错误检测码。

2、传输过程中包括校验位在内的奇数个数据位发生改变，那么奇偶校验位将出错表示传输过程有错误发生。

3、奇偶校验位是一种错误检测码，但是由于没有办法确定哪一位出错，所以它不能进行错误校正。发生错误时必须扔掉全部的数据，然后从头开始传输数据。

4、在噪声很多的媒介上成功传输数据可能要花费很长的时间，甚至根本无法实现。

5、它是使用一位数据能够达到的最好的校验码，并且它仅仅需要一些异或门就能够生成。奇偶校验被广泛应用。

**奇偶校验的用途：**
（1）奇偶校验是一种校验代码传输正确性的方法。根据被传输的一组二进制代码的数位中“1”的个数是奇数或偶数来进行校验。采用奇数的称为奇校验，反之，称为偶校验。

（2）单向奇偶校验(Row Parity)由于一次只采用单个校验位，因此又称为单个位奇偶校验。发送器在数据祯每个字符的信号位后添一个奇偶校验位，接收器对该奇偶校验位进行检查。典型的例子是面向ASCII码的数据信号祯的传输，由于ASCII码是七位码，因此用第八个位码作为奇偶校验位。

（3）奇偶校验只可以简单判断数据的正确性，从原理上可看出当一位出错，可以准确判断，如同时两个1变成两个0就校验不出来了，只是两位或更多位及校验码在传输过程中出错的概率比较低，奇偶校验可以用的要求比较低的应用下。同时，它不能纠错。在发现错误后，只能要求重发。