---
layout:       post
title:        "Astar搜索算法"
author:       "kalos Aner"
header-style: text
catalog:      true
tags:
    - 算法


---

## Astar搜索算法

A*搜索算法是一种启发式算法，利用现有的信息进行搜索的一种方法。

首先，定义横纵相邻方格之间的距离为**10**，对角相邻方格的距离为14（本文设定可以向8个方向前进，也可以根据需求设置为4个，比如只能横纵相邻方格间移动或者只能对角相邻方格间移动），以下用节点称呼方格。

定义每个节点除了位置坐标之外有两个属性

1、F值 = G + H，其中：

G = 从起点A移动到该节点的移动成本；

H = 从该节点到终点B的估算成本，仅计算横向和纵向移动，并且忽略障碍物。

2、父亲指针：指向从起点到该节点的路径中该节点的上一个节点。

我们假设某人要从 A 点移动到 B 点，但是这两点之间被一堵墙隔开。如下图，绿色是 A ，红色是 B ，中间蓝色是墙。

![image-20240907113731762](/img/in-post/image-20240907113731762.png)

**开始搜索：**

第一步：计算起点A的F值，然后把起点A添加到open list（表示可以搜索的位置，可以使用最小堆实现）中；

第二步：从open list中找到F值最小的节点，记为T，遍历节点T的8个相邻节点，对于每一个相邻方格进行以下处理：

​            1、     判断该相邻节点是否为障碍物或者在close list中，如果是则进行5，否则进行2；

​            2、     检查该相邻节点时候已经在open list中，如果在则进行3，否则进行4；

​            3、     计算该相邻节点的G值，检查这条路径是否更短，如果不是则进行5，否则进行4；

​            4、     计算该相邻节点的F值，将其的父亲指针指向节点T，然后加入open list，进行5；

​            5、     结束该相邻节点的处理。

把节点T从open list中删除并加入到close list中，如下图，绿色边框表示open list，浅蓝色边框表示close list。

![image-20240907113710249](/img/in-post/image-20240907113710249.png)

第三步：如果当前open list为空，则路径不存在，否则重复第二步，直到终点也加入open list，此时最优路径就是从终点的父亲节点进行回溯到起点。

![image-20240907113334496](/img/in-post/image-20240907113334496.png)